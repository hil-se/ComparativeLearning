"issuekey","type","components","storypoint","title","description_text"
"FAB-4221","Sub-task","fabric-docs",1,"update Getting Started link to resolve to v1.0.0-alpha3 bootstrap.sh","""create shortened URL that resolves to v1.0.0-beta tagged version of bootstrap.sh"""
"FAB-4219","Sub-task","fabric-build",1,"prepare Makefile for v1.0.0-beta","""BASE_VERSION = 1.0.0-beta   PREV_VERSION = 1.0.0-alpha3   IS_RELEASE = false"""
"FAB-4217","Sub-task","fabric-ca-build",1,"prepare Makefile for v1.0.0-beta","""PROJECT_NAME = fabric-ca   BASE_VERSION = 1.0.0-beta   IS_RELEASE = false"""
"FAB-4216","Sub-task","fabric-ca-build",1,"prepare Makefile for v1.0.0-alpha3 release","""BASE_VERSION = 1.0.0-alpha3   IS_RELEASE = true     """
"FAB-4215","Sub-task","fabric-build",1,"prepare Makefile for v1.0.0-alpha3 release","""BASE_VERSION = 1.0.0-alpha3   PREV_VERSION = 1.0.0-alpha2   IS_RELEASE = true    docs/source/releases.rst should be updated with prose and link to release page    change log should be generated and linked from docs/source/releases.rst"""
"FAB-4212","Task","fabric-build|fabric-ca-build|fabric-sdk-java|fabric-sdk-node",2,"Cut v1.0.0-alpha3 release","""Prepare and publish v1.0.0-alpha3 release of Hyperledger Fabric          Some related discussions also took place [here|https://docs.google.com/document/d/1mPTMjXG_b-mgZd2_EUN9W-82ez0PrWoxIiPgcAAABwE/edit#heading=h.7ylvqvqpim4]. """
"FAB-4325","Sub-task","fabric-docs",1,"create scheme to handle version-specific bootstrap.sh","""we need an ability to have version-specific bootstrap.sh"""
"FAB-4394","Sub-task","fabric-sdk-java",1,"create v1.0.0-beta release notes for fabric-sdk-java","""create release notes that generalize the changes since v1.0.0-alpha2"""
"FAB-4393","Sub-task","fabric-sdk-node",1,"create v1.0.0-beta release notes for fabric-sdk-node","""create release notes for v1.0.0-beta that generalize changes since v1.0.0-alpha2    generate changelog"""
"FAB-4392","Sub-task","fabric-ca-build",1,"create release notes for fabric-ca","""create release notes that generalize the changes since alpha2 to be used in release tag"""
"FAB-4391","Sub-task","fabric-build",1,"create release notes text for fabric","""create release notes for fabric text that generalize the nature of changes since v1.0.0-alpha2"""
"FAB-4390","Sub-task","fabric-sdk-java",1,"tag v1.0.0-beta release of fabric-sdk-java","""NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link"""
"FAB-4389","Sub-task","fabric-sdk-node",1,"tag v1.0.0-beta for fabric-sdk-node","""NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log      """
"FAB-4387","Sub-task","fabric-sdk-node",1,"publish v1.0.0-beta release node sdk","""See instructions in FAB-2802.    these will trigger CI to publish to npm:  fabric-client/package.json: version=1.0.0-beta  fabric-ca-client/package.json: version=1.0.0-beta    examples/balance-transfer update to target 1.0.0-beta artifacts for docker images, and fabric-client and fabric-ca-client npm"""
"FAB-4386","Sub-task","fabric-ca-build",1,"tag v1.0.0-beta release of fabric-ca","""     NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link    create change log"""
"FAB-4385","Sub-task","fabric-build",1,"tag v1.0.0-beta release of fabric","""NOTE: Tag release with the release_notes/v1.0.0-beta.md as the tag comment         % git tag \-a v1.0.0-beta \-F release_notes/v1.0.0-beta.md         tag release with a commit message that includes:    release notes    known vulnerabilities    other known issues    changelog link"""
"FAB-4384","Sub-task","fabric-docs",1,"update Getting Started link to resolve to v1.0.0-beta bootstrap.sh","""create shortened URL that resolves to v1.0.0-rc1 tagged version of bootstrap script    scripts/bootstrap-v1.0.0-rc1.sh"""
"FAB-4383","Sub-task","fabric-build",1,"prepare Makefile for v1.0.0-rc1","""BASE_VERSION = 1.0.0-rc1   PREV_VERSION = 1.0.0-beta   IS_RELEASE = false"""
"FAB-4382","Sub-task","fabric-ca-build",1,"prepare Makefile for v1.0.0-rc1","""PROJECT_NAME = fabric-ca   BASE_VERSION = 1.0.0-rc1   IS_RELEASE = false"""
"FAB-4381","Sub-task","fabric-ca-build",1,"prepare Makefile for v1.0.0-beta release","""BASE_VERSION = 1.0.0-beta   IS_RELEASE = true     generate changelog"""
"FAB-4380","Sub-task","fabric-build",1,"prepare Makefile for v1.0.0-beta release","""BASE_VERSION = 1.0.0-beta   PREV_VERSION = 1.0.0-alpha2   IS_RELEASE = true    docs/source/releases.rst should be updated with prose and link to release page    change log should be generated and linked from docs/source/releases.rst"""
"FAB-4379","Task","fabric-build|fabric-ca-build|fabric-sdk-java|fabric-sdk-node",2,"Cut v1.0.0-beta release","""Prepare and publish v1.0.0-beta release of Hyperledger Fabric          Some related discussions also took place [here|https://docs.google.com/document/d/1mPTMjXG_b-mgZd2_EUN9W-82ez0PrWoxIiPgcAAABwE/edit#heading=h.7ylvqvqpim4]. """
"FAB-4577","Sub-task","fabric-build",1,"add missing license headers to fabric-test-resources","""add missing license headers to fabric-test-resources"""
"FAB-4576","Sub-task","fabric-build",1,"address missing license headers fabric","""address missing license headers fabric"""
"FAB-4574","Sub-task","fabric-sdk-java",1,"address missing license headers fabric-sdk-java","""address missing license headers fabric-sdk-java"""
"FAB-4573","Sub-task","fabric-sdk-node",1,"address missing license headers fabric-sdk-node","""address missing license headers fabric-sdk-node"""
"FAB-4572","Sub-task","fabric-ca",1,"address missing license headers fabric-ca","""address missing license headers fabric-ca"""
"FAB-4608","Sub-task","fabric-quality",2,"Refactor the docker composition files for the test network topologies","""Currently, each network topology is defined in its own single file. It would prove useful for maintaining and reading if there were a single base component file that each network setup can use when setting up Fabric networks for system tests."""
"FAB-4971","Sub-task","fabric-quality",2,"behave test fmwk: could we check for existence of sub_elements in return data set","""Like being able to verify for an element from returned json structue:    Like for instance marble has dataset like: \{""""name"""", """"color"""", """"size"""", """"owner""""}:\{""""marble1"""",""""red"""",""""35"""",""""tom""""} when using marbles02 chaincode.    If i would like verify say owner of marble1, then may be I would have the following in my feature file     """
"FAB-5177","Story","fabric-peer",3,"peer/ccenv should not include the shim","""In the past, we made the decision to include the shim both as a convenience to our users (to avoid explicit vendoring) and as a space optimization (why have every chaincode include the same shim lib over and over?).    Fast forward to now: go dependency management leaves much to be desired.  Having the ccenv include the shim can be problematic w.r.t. fragility between the included shim and the chaincode application.  For example, try to write an application which uses the timestamp features of the shim and you will receive errors due to conflicts between the fabric vendored version of the protobuf library and the chaincode application.    Now that we have auto-vendoring, the convenience factor for including the shim is gone.  It only leaves the space optimization consideration.  Considering how fragile go dependency management is, we may want to go the conservative route and simply remove all dependencies from the ccenv and make """"peer package"""" / """"chaintool package"""" provide them via the auto-vendor feature.         If we are going to do this, we should do it before v1.0 is cut so that chaincode apps for 1.0 are properly formed in a non-breaking way going forward."""
"FAB-5236","Story","fabric-orderer",8,"Add orderer performance tests","""Today, all of our performance testing for the orderer is being done by spinning up an orderer process, bound to a port, then having external clients direct traffic to the ordering service.    This has been fine to get an overall impression of performance with the ordering code, but it's very time consuming and difficult to gauge the effect of performance improvements and to catch performance regressions.    Completion of this story should require the following:   # Refactor {{main.go}} so that the server can be started without binding to a real address, and instead supply a mock structure to register the gRPC services with.   # Create mock {{Broadcast}} clients which will submit properly signed messages via the {{Broadcast}} API. The number of clients should be arbitrary, and the message sizes should also be configurable, as should the desired channel.   # Create mock {{Deliver}} clients which operate similarly to the {{Broadcast}} ones.   # Create performance tests that leverage 1-3 to cover a variety of scenarios. Some which immediately come to mind:   ** 1 Broadcast and 1 Deliver, each going as fast as possible on a single channel   ** many Broadcast and 1 Deliver on a single channel   ** many Broadcast and many Deliver on a single channel   ** 1 Broadcast and 1 Deliver for each of many channels   ** many Broadcast and many Deliver for each of many channels   ** (a)-(e) each with small, medium, and large messages"""
"FAB-5258","Story","fabric-orderer",13,"Optimize orderer message processing flow to remove redundant checks","""The current orderer works in a two pass message filtering architecture.  The initial pass is done when the client invokes {{Broadcast}} and verifies that the message might be valid once ordered, then sends to the consenter for ordering.  After ordering, the consenter re-runs the verification on the messages as a second pass. This second pass ensures that the message is still valid, even after the other in-flight messages have committed.    The only cause of a message validating at {{Broadcast}} but not validating after ordering is if the channel configuration changes.  For instance, the max message size might be reduced, a certificate might be revoked, etc.    The problem with this architecture is that it implies that in the Kafka case, all messages are processed {{n+1}} times, where {{n}} is the number of OSNs.  In the Solo case, this implies messages are processed {{2}} times (as {{n}} is fixed to {{1}}.  However, in the green path, it should only be necessary to process the message {{1}} time.    The message verification step is the primary CPU bound (as it involves hashing and checking signatures) for the orderer, so improving from {{n+1}} to {{1}} has the potential to double or more the performance of the orderer.    To achieve this change, the orderer common components must be noticeably restructured.  The {{Broadcast}} path needs to include the config sequence at which the message was validated when pushing to consenus.  Then, the consenter needs to track changes in the config sequence number, trigger the second pass revalidation only when needed.  The message validation is currently buried within filters and filters within blockcutter, so this will need to be factored out into its own message processing package.    This is also a good opportunity to fix some of the directory structure which has accumulated considerable cruft during the v1 development.    Will add architectural diagrams."""
"FAB-5362","Sub-task","fabric-quality",3,"Behave test framework does not handle uppercase and mixchars in chaincode names ","""During deployment when behave tests are passed uppercase and mixchar names for chaincode names is tests fail.                 commit level:  Behave Fmwk: *d95525a64e7903565128d4c25ca522365ef6a926*  Fabric *b5c74cb8838d07f2101652a1c0acbb3b033a7660*{code}"""
"FAB-5545","Sub-task","fabric-build",1,"Set up Makefile to allow fabric to be a git submodule","""We would like to include the fabric repository as a git submodule in our repository as a dependency. Ideally, we would be able to build the necessary images and executables that are needed from this submodule.     Currently, the Makefile makes some assumptions that the directory structure will be """"hyperledger/fabric/..."""" The Makefile should be more flexible to allow for a different structure."""
"FAB-5645","Story","fabric-orderer|fabric-peer",8,"Split configtx processing and channelconfig dependency.","""The current configtx code was written under the assumption that it was managing a channel configuration.  Although there is some abstraction via the use of interfaces to make unit testing easier, it's not currently possible to use the configtx processing for something like the RSCC support.    This story is to remove the channel config specifics from the configtx package, and to factor the common components out of the channel config package into a common config package."""
"FAB-5732","Story","fabric-orderer",2,"Clarify policy evaluation errors","""The logs for policy evaluation can be quite unintuitive to the uninitiated.    This CR is to evaluate this logging and attempt to improve it to be less opaque."""
"FAB-5721","Sub-task","fabric-crypto",2,"As I fabric developer I want the SCCs to use the new ACLProvider to enforce access control","""The new ACLProvider offers a centralised way to manage access control to resources on channels. The following SCCs will be updated to use it: QSCC, CSCC, LSCC, Endorsement (Proposal and CC2CC)."""
"FAB-5864","Story","fabric-samples",3,"Reconfigure membership in examples.","""How to conduct channel membership changes is a frequently asked question.    The tools are all there, and there is some fragmented documentation around this, but the best way to document is through example.    It should be relatively straghtforward to enhance one of the examples to define three application organizations instead of 2, then create a channel with two members, and add the third.    This is an exercise that I've gone though by hand and would be happy to walk the implementer through."""
"FAB-5966","Story","fabric-samples",5,"Balance Transfer sample application using Fabric Java SDK","""A *balance transfer* spring boot application using +fabric SDK java+ which will demonstrates all the basic _functionalities_ of *hyperledger 1.0*, such as enrolling and registering user , creating channel , installing chaincode , instantiating chaincode , invoking chaincode and querying chaincode. I have created this sample application for reference so that people who want to develop a hyperledger fabric solution using Java SDK can use the sample to accelerate their application development."""
"FAB-6091","Sub-task","fabric-build",1,"Build with Go 1.9 by default","""The final step is moving to Go 1.9 is to actually build with Go 1.9.  In order to do this, we just need to move to a baseimage which uses Go 1.9"""
"FAB-6635","Sub-task","fabric-quality",2,"Add ability to execute on command line","""The ability to execute openssl commands and use the output in the test will assist in the encryption testing."""
"FAB-10219","Story","fabric-crypto",1,"Usability: idemixgen user versus admin difference","""It's not clear how you can tell that you are using an admin setup or a user setup after using the tool. The output all goes to a directory """"user"""". How do I know that the admin flag worked as expected?"""
"FAB-10729","Story","fabric-peer",2,"As a peer org admin, I need a chaincode API to define a chaincode","""This story corresponds to the 'Define' step in the design document from FAB-8787.    The implementation should add a new chaincode function called {{Define}} which accepts a new message as its only parameter.  This message should have a single field, corresponding to the {{Definition}} message as defined in FAB-10726.  It should return a new empty message.    It should read from the organizations private store the key at <hash> and verify that each the messages are equal or fail.  It should use protobuf equality checking rather than direct bytes comparison.    Next, it should check to see whether the world state key <chaincode_name> is set.  If so, it should should read the bytes there, unmarshal it as a chaincode definition, and check that the sequence contained in the new definition is exactly one larger than the existing sequence number or fail.  If the key does not exist, it should ensure that the sequence number is 0 or fail.    Finally, it should marshal the definition and store it at world state key <chaincode_name> and return the empty message successfully."""
"FAB-10726","Story","fabric-peer",2,"As a peer org admin, I need a chaincode API to signal my approval to execute a chaincode with certain parameters on a channel","""This corresponds to the 'InstallChaincodeMetadata' step described in the FAB-8787 design document.    This chaincode API should be called {{AgreeToDefine}} and should accept as input a message containing a single field {{Definition}} which is itself a protobuf message with the fields:  # Name as a string  # Version as a string  # Sequence an unsigned 64 bit integer  # Hash as bytes (corresponding to the hash returned by FAB-10725)  # Endorsement plugin as string  # Validation plugin as string  # ValidationParameter as bytes    The chaincode API should return an empty protobuf message.    The function should first verify that the user is an administrator of the org per the channel configuration.  Then it should then take the {{Definition}} and put it in the organization's private data collection at key """"<hash>"""".    Note, the ability to write to an org scoped collection does not exist at the time of writing this story, but should be implemented via FAB-8864."""
"FAB-10725","Story","fabric-peer",2,"As a peer admin, I need a chaincode API to install ChaincodeInstallPackages.","""The new lifecycle system chaincode needs to expose a function to allow the installation of ChaincodeInstallPackages.    It should take as a parameter a message containing the name, version, and ChaincodeInstallPackages.  It should return a message containing the hash of the code package.    The chaincode function name should be {{InstallCodePackage}}    Both the input and output should be new protobuf messages so that we may use the protobuf versioning mechanisms to extend and deprecate fields.    It should declare a new interface which declares the dependency on the function provided by FAB-10720 to store the package."""
"FAB-10724","Story","fabric-peer",1,"As a fabric developer, I need a way to retrieve the hash of a persisted ChaincodeInstallPackages by name/version.","""FAB-10720 introduces a way to persist chaincode packages onto the filesystem and FAB-10723 introduces a way to retrieve those packages by hash.    However, users may not know the hash of their installed chaincode by may only know the friendlier name/version. In this case, we will need to be able to look up the hash by name/version. Once the correct hash is known, the existing API for retrieving the code bytes themselves may be used.    The implementation should accept name/version as parameters, and return a byte slice which is the hash."""
"FAB-10723","Story","fabric-peer",1,"As a fabric developer, I need a way to retrieve persisted ChaincodeInstallPackages by hash.","""FAB-10720 introduces a way to persist the chaincode install packages.  In order for this to be useful, this persistence mechanism must also allow chaincodes to be retrieved.    The implementation should accept a package hash (corresponding to the hash of the marshaled chaincode install package) and retrieve the package itself, as well as the stored name and version associated with this package."""
"FAB-10720","Story","fabric-peer",2,"As a fabric developer, I need a way to persistently store ChaincodeInstallPackages.","""As part of the new lifecycle work, there is a new chaincode package format as defined via FAB-10719.  In order for the new life cycle to use this new package format, it needs a way to persist these code packages.    The existing persistence is done through the ccprovider package, however, because of the legacy and problematic nature of this code (package scoped state and functions), and the irrelevant details like instantiation policy, extending the existing mechanisms is likely to be more work than simply creating a new persistence system.    This new persistence should take as a parameter a name, a version, and a set of bytes.  This set of bytes is a marshaled form of the the new message from FAB-10719.    The persistence should use the existing configurable chaincode storage directory to store chaincodes, but instead of storing them as '<name>.<version>' as the current code does, it should store the marshaled package and the package name/version as {{<hash_of_chaincode_install_package>.bin}} and {{<hash_of_chaincode_install_package>.json}} respectively.    The implementation should be careful not to expose these details to the user.    The implementer should evaluate whether creating a new file in the ccprovider package, or simply creating a new package is more sensible for this work."""
"FAB-10719","Story","fabric-peer",1,"As chaincode developer, I need a new message type to serialize chaincode install packages.","""The new lifecycle work will need a way to store chaincode to the filesystem.  Today, the peer stores chaincode either in a CDSPackage or SignedCDSPackage, both of which are inappropriate for the new lifecycle.    These existing package formats include references to legacy datastructures that do not make sense in the new lifecycle world, such as instantiation policy, and conflate things which identify the chaincode (ie, its name, version, and hash) with properties of the chaincode itself (such as its type, and code).    This should be a new protobuf message named {{ChaincodeInstallPackage}}. which includes:   # {{Type}} as a string (ie, go, java, node)   # {{Path}} as a string (as required by some of the current platform packages)   # {{CodePackage}} the package itself as bytes (typically a tar file)."""
"FAB-11300","Story","fabric-crypto",5,"As a token-based application/client developer, I can submit a transaction for  issuing new tokens into the system","""Here the client token library leverages the responses from the prover peer to create a token transaction for issue that is submitted to the ordering service."""
"FAB-11299","Story","fabric-crypto",2,"As a token-based application/client developer, I can create and submit a transaction to request the  transfer of my tokens","""Here the client token library leverages the responses from the prover peer to create a token transaction for transfer that is submitted to the ordering service."""
"FAB-11298","Story","fabric-crypto",2,"As a token system client developer, I can request from a peer to compute a transfer proof matching my transfer token needs","""{color:#333333}Acceptance: A client function (cwLib) takes as arguments the identifiers of the tokens {color}{color:#333333}to be transferred and the expected recipients. As a result the function would request from a peer to construct the corresponding transfer proof. The transfer proof is returned to the client and the function will return successfully only if the returned transfer proof is correctly computed.{color}  {color:#333333} {color}"""
"FAB-11297","Story","fabric-crypto",2,"As a token-based application/client developer, I can query  the ledger through a peer I trust to list my tokens into the system ","""*Acceptance*: Client wallet library for token operations in Fabric is enhanced with a function that takes as arguments the long term identity of an end-user and queries a peer on the set of tokens that this end-user owns. The peer receives the request and acts according to the specification of previous story."""
"FAB-11296","Story","fabric-crypto",2,"As a token-based system client developer, I can request from a peer to compute an issue proof matching my issue needs ","""{color:#333333}{color:#333333}Acceptance: A client function (cwLib) takes as arguments the type and quantity of assets to be introduced into the system via a token issue process. As a result the function would request from a peer to construct the corresponding issue proof. {color}{color}  {color:#333333} {color:#333333}The issue proof is returned to the client and the function will return successfully only if the returned issue proof is correctly computed.{color}{color}"""
"FAB-11294","Story","fabric-crypto|fabric-peer",2,"As a  token infrastructure (peer) developer, I want to accommodate “list of my tokens” requests","""*Acceptance*: A fabric client can be built to submit a “list tokens” query to a peer.  Peer considers the current ledger state and returns the tokens owned by the   creator of the query; if the creator of the query does not have permission to read  the channel’s data, the request is rejected; if the creator of the query does not own  any tokens the peer would return an empty list. The client can observe the correctness  of successive “list my tokens” queries in correlation with the content of the ledger."""
"FAB-11293","Story","fabric-crypto|fabric-peer",3,"As a token infrastructure (peer) developer, I want the peer to accommodate requests to compute an issue proof given specific parameters","""*Acceptance*: A (simulated) client constructs a request to construct an issue proof by   providing the type and quantity of assets to be introduced into the system, and invokes   the peer API. The peer would need to construct the corresponding issue proof and return   it to the (simulated) client. Acceptance would require that the constructed proof matches   the input parameters of the request."""
"FAB-11292","Story","fabric-crypto|fabric-peer",2,"As a token infrastructure (committing peer) developer, I can fully process a “transfer tokens""  transaction ","""Given FAB-11942, and FAB-11371 this item refers to the testing that the transfer transactions can be correctly processed by the existing tx processor and TMS implementation."""
"FAB-11291","Story","fabric-crypto|fabric-peer",2,"As a token infrastructure (committing peer) developer, I can recognise and process a  “transfer tokens"" transaction without impacting the ledger state","""*Acceptance*: A (simulated) client generates a “transfer tokens"""" transaction.    Upon receiving this transaction, a committing peer redirects its processing to its    FabToken specific validation & commit components.  The transaction is to be   marked as invalid in the end and will have no impact on the ledger state.         This one relates to the extension of proto messages to accommodate transfer   transactions and of the corresponding test, testing that transfer token transactions   go through the right path.    The first part was already completed (proto messages definition). The second is   blocked by  FAB-11175."""
"FAB-11287","Story","fabric-crypto|fabric-peer",5,"As a token infrastructure (committing peer) developer, I can fully process an ""issue tokens""  transaction ","""   *Acceptance*: A (simulated) client generates an """"issue tokens"""" transaction that is submitted  to the system.  Upon receiving this transaction, a committing peer redirects its processing to its   Token specific validation & commit components.  FabToken custom validation ensures that  the tokens requested to be issued are of the right form (e.g., of acceptable type), and custom   commit ensures that the transaction creator is authorised to issue tokens.  Upon successful  transaction validation and commit, the ledger state is updated to reflect this. The ledger APIs   can be used to retrieve the committed data. """
"FAB-11286","Story","fabric-crypto",3,"As a token application developer, I want to initialise a simplified Token client library using sample FabToken parameters without signing abilities","""{color:#333333}Acceptance: I can setup the token client library using a fixed set of token parameters, and monitor the internal state of the created client to ensure that its initialization took place with the right parameters. The client library would not provide any further functionality at this point beyond setup.{color}"""
