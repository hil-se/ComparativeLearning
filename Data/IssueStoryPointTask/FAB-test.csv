"issuekey","type","components","storypoint","title","description_text"
"FAB-11285","Story","fabric-crypto|fabric-peer",2,"As a token infrastructure developer, I want the committing peers to setup a Token-specific validation and transaction processor components using a fixed set of parameters for a channel","""Transaction processing at committing peer side consists of validation (vscc) & commitment (performed by a transaction processor component). The token-related setup of the committing peer expands on both components.    *Acceptance*: I can setup the peer using a fixed set of fabtoken parameters, and monitor the internal state of the peer to ensure that FabToken initialisation took place with the right parameters."""
"FAB-11355","Story","fabric-crypto",5,"As a token infrastructure (peer) developer, I would like to implement the processing of TLS-authenticated client requests ","""Prover peer grpc service is now ready to fully process TLS-authenticated client requests to for proof computation. At the end of this item acceptance criteria of the parent item should be fulfilled."""
"FAB-11535","Task","fabric-peer",2,"Add round trip usage of the new chaincode install and query installed chaincodes function to e2e","""With the implementation of the peer chaincode package, peer chaincode install, and peer chaincode list for the new lifecycle, it should be possible to test these using the e2e framework.    There is likely no need to create an entire new suite for this with a new network, but extending an existing suite should be straightforward.    The test should package a chaincode, install that package, and verify that the package is returned as installed."""
"FAB-11534","Story","fabric-peer",2,"As a fabric admin, I need a way to query installed chaincode packages from the new lifecycle.","""This story is to extend the existing 'peer chaincode list"""" command to support listing installed chaincodes via the new chaincode API.    The operation should be the same as before, but it should add a new '-N' parameter to indicate that the new lifecycle should be utilized, instead of the old.  It should invoke the '+lifecycle.QueryInstalledChaincodes' API, and print a list of name, version, hash.    Note, for the time being it is necessary to only allow querying installed chaincodes with '-N', the instantiated chaincodes will be covered in another story."""
"FAB-11533","Story","fabric-peer",3,"As a fabric admin, I need a way to install a new chaincode package.","""This is to exercise the new +lifecycle.InstallChaincode API.    It should extend the existing 'peer chaincode install' command.  It should require that a package be provided as input (to avoid non-deterministic multiple-packaging), and invoke SCC function.  It should require the 'name' and 'version' parameters, but the 'language' and 'path' parameters should not be allowed.     Like the other new lifecycle commands, it should distinguish itself from the old APIs by requiring a """"-N"""" parameter."""
"FAB-11532","Story","fabric-peer",3,"As a fabric admin, I need a way to inspect the new chaincode package format.","""Because in the new lifecycle scheme, we will require that the package hashes are consistent, users will need to share chaincode packages.  However, there should be no centralized point of trust, so each user should be able to verify that the chaincode package contains the expected code.    Therefore, we need to extend the """"peer chaincode package"""" command to be able to extract a chaincode package and write it out to disk.      This should be accomplished with a new chaincode sub-command 'inspectpackage'.  It should take a path to the chaincode package, and optionally a location to extract it to (defaulting to the current directory).  It should then extract the embedded code package."""
"FAB-11671","Story","fabric-token",5,"As a token-based system client developer, I can request from a peer to compute a token redemption proof matching my token redemption needs","""{color:#333333}*Acceptance:* A client function (cwLib) takes as arguments the identifiers of tokens to be redeemed via a token redemption process. As a result the function would request from a peer to construct the corresponding token redemption proof. {color}    The redemption proof is returned to the client and the function will return successfully only if the returned issue proof is correctly computed."""
"FAB-13067","Task","fabric-orderer",1,"Expose orderer blockcutter metrics","""The only real tunables for the orderer as far as latency and throughput  goes is the batch parameters.  Therefore, it's critical for network  operators to be able to gain insight into the duration filling a block  takes to know whether they should relax or tighten their batch  parameters."""
"FAB-13895","Story","fabric-build",2,"As a developer, I want to our 1.4 stream to build against the latest release of go 1.11","""The current version of 1.11 is 1.11.5 and includes security related fixes for crypto/elliptic.    We need to bump the version of go that we build with in fabric, fabric ca, our docker images, and all of the other miscellaneous places - including our build environments in CI."""
"FAB-13894","Story","fabric-build",2,"As a developer, I want to use go 1.11.5 while developing on master","""The current version of 1.11 is 1.11.5 and includes security related fixes for crypto/elliptic.    We need to bump the version of go that we build with in fabric, fabric ca, our docker images, and all of the other miscellaneous places - including our build environments in CI."""
"FAB-14492","Story","fabric-peer",3,"As a fabric operator, I want a custom builder to be invoked when my detect script exits normally","""Acceptance:    I can drop a {{build}} script the peer's local file system next to the {{detect}} script. When the {{detect}} script  exits successfully, the {{build}} script will be called. The arguments to the build script should be the extracted contents of the chaincode package, a directory to place chaincode metadata for the peer (ie. CouchDB index files), and a directory to place assets that may be needed to launch chaincode.    If the {{build}} script exits abnormally, the build process has failed."""
"FAB-14491","Story","fabric-peer",3,"As a fabric operator, I want the peer to execute a binary I configure to determine if a custom builder should be used","""Acceptance:    I can add keys to {{core.yaml}} that point to a path in the peer's local file system that contains a {{detect}} binary. If it exits, it is called prior to building chaincode. No further action is required.    System chaincode never uses the external launcher."""
"FAB-15313","Sub-task","fabric-orderer",1,"Address remaining test comments from https://gerrit.hyperledger.org/r/c/31076/4","""Comments regarding the assertions in {{TestSelectClusterBootBlock}} need to be addressed.  Gerrit has the details but here are the comments:    {quote}  I think you either want to use assert.Same(t, bootstrapBlock, clusterBlock) so ensure you're getting back the exact same instance (ptr value) or just use assert.Equal(t, bootstrapBlock, clusterBoot) to ensure that the values pointed to are equal. The header number assertion is implied with the equality check.    Unrelated but for awareness (you may already know) - if proto objects get marshaled/unmarshaled, assert.Equals won't necessarily work and you'll have to use proto.Equal to check the values.  {quote}"""
"FAB-15709","Story","fabric-orderer",2,"Allow orderer startup with no channels defined","""Today, if the orderer does not have any channels defined, it panics because it cannot find the system channel.  This story is to remove those startup checks to allow the orderer to start successfully, even though it will not be in a position to accomplish anything.  This should also block channel creation requests if no system channel is defined to route them to."""
"FAB-15708","Story","fabric-orderer",2,"Add 'None' genesis method for orderer configuration","""Today, the orderer may be given one of two genesis methods 'Provisional' or 'File'.  In the 'Provisional' case (useful only for testing) the orderer generates a genesis block based on a configtx.yaml file, while in the 'File' case, the orderer loads a file from the filesystem.    In order to ultimately allow the orderer to start without chains defined, we need to allow a genesis method which does not attempt to do anything.  This genesis method should be called 'None', and should not trigger loading of the genesis file, nor generation of a genesis block.    ----    If you supply None as the genesis method for an orderer that has not been bootstrapped, the orderer should panic.  If you supply None as the genesis method for an orderer that has already been bootstrapped and the genesis file is not available, it should start normally.  """
"FAB-15732","Story","fabric-peer",2,"As a chaincode developer, I want {{chaincode package}} to honor *all* of my dependencies","""The {{chaincode package}} command includes some logic to filter packages that the ccenv includes. This means that older or newer versions of these packages (used during development) will not be included in the package that's installed to the peer.    As a developer, when the """"auto-vendoring"""" process is performed, I would like my code to be included at all times."""
"FAB-16046","Story","fabric-cli",2,"As a Fabric user, I want to instantiate chaincode using the CLI with a policy requiring multiple orgs","""    does not support the {{--peerAddresses}} flag which is needed when using instantiation policies which require more than one org."""
"FAB-16206","Story","fabric-peer",3,"External builder detect should not need to parse flags","""The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    detect should be provided a directory containing metadata.json (holding metdata as a basic map) and a reference to a directory containing the exploded source.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model."""
"FAB-16216","Story","fabric-peer",3,"External builder launch should not need to parse flags","""The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    launch receives directory containing metadata, the source the directory, the output directory from build, and an artifacts directory that contains file necessary for launch (key, cert, address, etc.). The artifacts must have well known names.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model."""
"FAB-16215","Story","fabric-peer",3,"External builder build should not need to parse flags","""The first pass of the detect, compile, launch infrastructure was implemented with a collection of  command line switches. This will become unwieldy over time as implementers will have difficulties ignoring unknown flags and parameters - especially flags that accept values.    Instead we should remain consistent with the buildpack model that already exists - namely, we provide a list of directories that contain extracted files. If we need to provide more data, we can add an additional argument or populate additional files. This means that implementations should ignore extra arguments as a general rule until they know what they point to.    build should receive receive arguments for the metadata directory, a directory containing the extracted source, and a directory for it to store its output.    Acceptance: external scripts do not need to process flags; existing parameters are reworked to fit this model."""
"FAB-16213","Story","fabric-common",2,"Remove ext/entities from the go chaincode packages","""The dependency on bccsp prevents proper structuring of the code and will result in a rewrite of the package. The proposal from [~mastersingh24] is to remove the code and, if we need to recreate it, we can do it when the package has been extracted from fabric.    Acceptance: there are no fabric dependencies in shim extensions other than the protos."""
"FAB-16239","Story","fabric-peer",2,"External builders should run in controlled environment","""By default, when a process is started, it inherits the environment of its caller. In the context of external chaincode, the environment of the peer is propagated to the builder. Given most users of the peer rely on environment variables to influence the configuration, it's quite likely that sensitive information is accessible in the environment.    In order to reduce the likelihood of information leaks via the environment, the external build configuration element in the peer should be extended to support and environment variable name whitelist. Any environment keys in that list will be propagated to the external builder.    The default list should contain PATH, LIBPATH, and TMPDIR. It's likely that environment variables like http_proxy/HTTP_PROXY will be added by users."""
"FAB-16661","Story","fabric-peer",2,"Consistently provide PEM encoded keys and certificates to chaincode platform implementations","""[~jyellick] highlighted something about the launch contract that we should try to address moving forward.    The client key and client cert that we provide to the chaincode are base64 encoded PEM blocks while the root certificate is simply the PEM block.    The base64 encoding of the PEM blocked (already encoded) certificate is really weird... Unfortunately, we can't just change it as existing chaincode will be decoding so we need to add mitigation/migration.    [https://github.com/hyperledger/fabric-chaincode-go/blob/8f8a45e6039e7bc0e03a042591b010317481f21d/shim/internal/config.go#L48-L67]    The thought is that we can create two new files that contain the pem blocks (instead of base 64 encoded pem blocks) and use new keys to reference them. The old config and format would be deprecated and ultimately removed.    This will impact the run step of the launcher as well (in a different story)...    The go shim should be updated to prefer the non-double-encoded certificates. Node and java should not.    Acceptance: I can run chaincode build with the old and new go chaincode shim."""
"FAB-16722","Story","fabric-orderer",3,"Remove the ""provisional"" system channel genesis block support from the orderer","""The generation of a system channel genesis block is not a core function of the orderer. Even though it could be somewhat useful in test environments, from a technical perspective, it requires the orderer to include and use the """"sample"""" {{configtx.yaml}} in addition to the orderer's own {{orderer.yaml}}.    From a process and deployment perspective, it's better to have the system channel genesis block explicitly created by administrators with real names than to rely on fixtures that were originally intended for test.    For these reasons, we should remove the provisional genesis method from the orderer, it's associated artifacts, and documentation. The removal should be highlighted in release notes.    Acceptance: code supporting """"provisional"""" is gone, documentation for the feature is removed, and a release note highlighting the removal is created."""
"FAB-16721","Story","fabric-peer",2,"Ensure that go chaincode can be used with the release 1.4 ccenv","""With the removal of the fabric/chaincode/shim and dependencies from the v2 ccenv, chaincode packaged for previous releases can't be built with by a 2.0 peer.    It's inevitable that previously built chaincode docker images will be removed and, when that happens, the previously installed 1.x chaincode will need to be built by a 2.x peer. This will fail for go chaincode when using the 2.x version of ccenv.    To help get out of this mess, we need to verify that the peer can be successfully configured to use the hyperledger/fabric-ccenv-1.4 as the builder image.    /cc [~mastersingh24], [~jyellick]"""
"FAB-16858","Story","fabric-docs|fabric-peer",2,"Generate user consumable documentation for external builder/fabric buildpack/external launcher","""Create draft of documentation for the external build and launch infrastructure for Fabric. This should include introductory material, rationale, and reference data for implementors.    The documentation will need to be massaged by the technical writing team for Fabric and adapted for use in the correct locations."""
"FAB-17001","Story","fabric-peer",2,"New lifecycle should cleanup from failed build during install","""When using the new lifecycle to install chaincode, if the build fails due to timeout or some other reason such that the """"endorsement"""" fails at the peer, the chaincode package should be removed from the local file system.    This prevents an odd behavior where the invoke of a chaincode that failed to build (during install) succeeds."""
"FAB-17047","Story","fabric-peer",3,"RuntimeLauncher needs to be extended to support Stopping or disconnecting from chaincode","""Chaincode execution is currently managed through RuntimeLauncher. The launcher needs to be extended to include a """"Stop"""" verb to properly disconnect from / shutdown running chaincode that is launched through the external/container/platform packages."""
"FAB-17046","Story","fabric-peer",2,"When chaincode defined with the new lifecycle are no longer defined in any channel, they should be stopped","""There is a state listener in the new lifecycle that tracks when chaincode is invocable (or not). Today, when a chaincode becomes invocable, we call the custodian to start it... A similar call needs to be made when a chaincode is no longer invocable to request the custodian to stop it.    The lifecycle cache already has a reference counted list of channel references to chaincode.    Acceptance:  1. Install chaincode with a name and package-ID """"A""""  2. Define chaincode  3. Install chaincode with name and package-ID """"B""""  4. Upgrade chaincode definition to """"B""""  5. Observe that chaincode container for package-ID """"A"""" is stopped.    This story applies to internal platform chaincode and externally built and launched chaincode."""
"FAB-17093","Story","fabric-peer",3,"Add a basic test that confirms expected proto types get decorated.","""Per https://gerrit.hyperledger.org/r/c/fabric/+/34401#message-eccb8901_793a8c92    The protolator decoration stuff https://github.com/hyperledger/fabric/blob/33139a966bb75377f65c5d9dc990619bd80ca22d/common/tools/protolator/protoext/decorate.go is currently missing any sort of tests.    Some changes would be caught by integration tests, but a more  basic level of unit testing, ensuring that we are not accidentally omiting decoration of a type we intend to decorate would be nice."""
"FAB-17310","Story","fabric-peer",3,"Enable service discovery to query the _lifecycle endorsers on a channel","""Similar to using service discovery to determine the endorsers needed to meet a user-defined chaincode's endorsement policy, we should also be able to use it to discover the endorsers required to commit a chaincode definition using _lifecycle.    Acceptance:  - Query _lifecycle on a specific channel and receive the valid list of endorsers required to meet the endorsement policy. (Version does not come into play.)    The list of endorsement should match the active configuration. This will likely involve creating a test with a non-standard _lifecycle endorsement policy."""
"FAB-17469","Story","fabric-common",2,"Implement orderer configuration transaction that can update batch parameters","""As a fabric administrator, I want to use a fit-for-purpose library to generate a channel update transaction that modifies the {{max_message_count}} batch size parameter. The channel update transaction that is generated should not be signed.    Acceptance    Calling the new function with appropriate arguments should generate a config update transaction that matches one produced by manually transforming and generating a configuration update using the existing tools (ignoring any signature that may be applied by the existing tools)."""
"FAB-17468","Story","fabric-common",2,"Implement function to attach signatures to a configuration update transaction","""As a fabric admin, I want to take a {{ConfigUpdate}} transaction and a collection of detached signatures and use them to create a complete, signed channel config update transaction that can be validated by the orderer and the peers.    Acceptance:    The generated configuration transaction should be equivalent to one generated by """"building up"""" signatures in order using the existing `signtx` command on the peer."""
"FAB-17467","Story","fabric-common",2,"Implement function to create a detached signature for a ChannelUpdate","""As a fabric admin, I wish to sign a {{ChannelUpdate}} transaction and generate a detached signature. The key material used to sign the transaction should be one of the input parameters and should not be derived from configuration.    Acceptance:    Calling the new function with appropriate arguments generates a detached signature that I can use later as one of the _n_ required signatures when assembling the configuration update transaction."""
"FAB-17466","Story","fabric-common",5,"Implement function to generate create channel transaction from parameters","""As a fabric administrator, I want to use a fit-for-purpose library to generate a channel creation transaction from input data structures. This library should not make assumptions about how any key material is stored and should not require network access.    Acceptance:    Calling a function similar to what we have below returns a proto-encoded genesis block that roughly matches that produced by {{configtxgen -channelID channel-id -profile profile-name ...}} using a prototypical {{configtx.yaml}} from our integration test suite.    Generating a genesis block from the configtx.yaml and an msp folder, and using code implemented in this story, I should get two `proto.Equal` blocks.        The types that are listed above come from the {{genesisconfig}} package in fabric and appear to be managed through a combination of viper and yaml processing. We do not want to use these packages directly; we want to copy and adapt the necessary structures into our package."""
"FAB-17488","Story","fabric-common",3,"Implement function to compute a ConfigUpdate from a base and modified configuration transaction","""As a fabric administrator, I want to use a fit-for-purpose library function to calculate a ConfigUpdate message that would update a {{base}} config to the {{modified}} config. This function should not need to be provided with anything beyond the two transactions.    Acceptance    Calling the new function with appropriate arguments should generate a {{ConfigUpdate}} that is semantically equivalent to the output of {{configtxlator compute_update}}.    See https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html for the current manual process."""
"FAB-17487","Story","fabric-common",2,"Implement function to generate ConfigGroup for a new Organization","""As a fabric administrator, I want to use a fit-for-purpose library function to generate a ConfigGroup representing an Organization. The input to the function should not depend on existing MSP material but should accept directly the necessary cryptographic material.    Acceptance    Calling the new function with appropriate arguments should generate a proto structure that is semantically equivalent to one generated by {{cryptogen}} and {{configtxgen -printOrg}}."""
"FAB-17546","Story","fabric-common",2,"Implement function to add a root CA to an MSP","""As an administrator, I want to use a fit for purpose library to add a new root CA certificate to an MSP configuration.    Acceptance:  Starting with a configuration transaction/block, I can call a function that adds CA certificate to the MSP configuration. After this operation, I should be able to create a config update transaction that is ready for the signature workflow.    Minimal certificate validation should be done when processing the function. In particular, reject certificates that is missing the KeyUsageCertSign/CA attributes."""
"FAB-17545","Story","fabric-common",3,"Implement function to revoke a certificate issued by an MSP","""As a fabric administrator, I want to use a fit for purpose library to generate a configuration update that revokes a certificate issued by my organization's MSP.    Acceptance:   Provided with a config block/transaction, I can call a function to """"revoke"""" a certificate issued by an MSP. This should result in a configuration update that appropriately modifies the {{revocation_list}} attribute of {{FabricMSPConfig}}."""
"FAB-17544","Story","fabric-common",1,"Implement function that removes an anchor peer","""As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to remove an anchor peer.    Acceptance:  Starting with an existing Config block/transaction, I can call a function that removes an anchor peer from the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow.    https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html#updating-the-channel-config-to-include-an-org3-anchor-peer-optional"""
"FAB-17543","Story","fabric-common",2,"Implement function that adds an anchor peer","""As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to add an anchor peer.    Acceptance:  Starting with an existing Config block/transaction, I can call a function that adds an anchor peer to the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow.    https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html#updating-the-channel-config-to-include-an-org3-anchor-peer-optional"""
"FAB-17552","Story","fabric-common",2,"Implement an Example test that demonstrates idiomatic usage of the library","""As a user of the Fabric channel configuration API, I would like an example in the library documentation that shows me idiomatic usage of the package to create configuration updates and sign them. The updates should involve multiple changes to instruct on how state is managed.         *Acceptance*    I can find an example for updating channel transactions in the GoDoc for the package. It should also sign the config update envelope."""
"FAB-17577","Story","fabric-common",1,"Rename pkg/config to something more appropriate","""config as a package name isn't very descriptive of what this package is. We should consider renaming the package to something more appropriate for what it actually does (maybe configtx?)"""
"FAB-17576","Story","fabric-common",1,"Implement helper function for retrieving msp configuration for a specific org from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing msp configuration for an organization without manually parsing the config transaction so I can reuse CA certs or other relevant information.         *Acceptance*    I should be able to call a function for retrieving msp configuration for a specific org. The example test should also be updated to demonstrate usage of this helper."""
"FAB-17572","Story","fabric-common",1,"Implement function for adding and removing policies for consortium orgs and consortiums/consortium groups","""As a user of the Fabric channel configuration API, I would like to be able to update a consortium org's, consortiums group's, and consortium group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     """
"FAB-17571","Story","fabric-common",1,"Implement functions for adding and removing policies for orderer orgs and orderer group","""As a user of the Fabric channel configuration API, I would like to be able to update an orderer org's and orderer group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     """
"FAB-17570","Story","fabric-common",1,"Implement functions for adding and removing policies for application orgs and application groups","""As a user of the Fabric channel configuration API, I would like to be able to update an application org's and an application group's configuration by adding or removing policies.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     """
"FAB-17569","Story","fabric-common",1,"Implement helper function for retrieving an org's configuration from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing application, orderer, or consortium org configuration without manually parsing the config transaction so I can persist values I don't want to change when updating an org's configuration.         *Acceptance*    I should be able to call a function for retrieving an application, orderer, or consortium org's configuration that returns a config.Organization. I can then modify fields on the Organization and pass it to an appropriate update organization function to update the org's configuration. The example tests should also be updated to demonstrate usage of this helper."""
"FAB-17568","Story","fabric-common",1,"Implement helper function for retrieving orderer configuration from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing orderer configuration without manually parsing the config transaction so I can persist values I don't want to change when updating orderer configuration         *Acceptance*    I should be able to call a function for retrieving orderer configuration that returns a config.Orderer. I can then modify fields on the Orderer configuration and pass it to config.UpdateOrdererConfiguration to update the orderer's configuration. The example tests should also be updated to demonstrate usage of this helper."""
"FAB-17567","Story","fabric-common",1,"Implement helper function for retrieving anchor peers from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing anchor peers without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving anchor peers for a specific org. The example test should also be updated to demonstrate usage of this helper."""
"FAB-17565","Story","fabric-common",2,"Implement an Example test that demonstrates creating a new create channel tx","""As a user of the Fabric channel configuration API, I would like an example in the library documentation that shows me idiomatic usage of the package to create new channel create transactions and sign them.         *Acceptance*    I can find an example for creating create channel transactions in the GoDoc for the package."""
"FAB-17587","Story","fabric-common",2,"Verify that a cert is issued by an MSP before adding to revocation list","""As a fabric administrator, I want to verify that a cert was issued by my organization's MSP before adding it to the MSP's revocation list.    Acceptance:   Provided with a config block/transaction, I can call a function to """"revoke"""" a certificate issued by an MSP. This should result in a configuration update that appropriately modifies the {{revocation_list}} attribute of {{FabricMSPConfig}}.    Providing a certificate that has not been issued by the MSP should result in an error."""
"FAB-17592","Story","fabric-common",1,"Implement function that removes an orderer endpoint","""As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to remove an orderer endpoint from an orderer org's config group.    Acceptance:   Starting with an existing Config block/transaction, I can call a function that removes an orderer endpoint from the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow. An appropriate example should also be added to the example test that demonstrates this behavior."""
"FAB-17591","Story","fabric-common",1,"Implement function that adds an orderer endpoint","""As a fabric administrator, I want to use a fit-for-purpose library that can modify an existing channel configuration to add an orderer endpoint to an orderer org's config group.    Acceptance:   Starting with an existing Config block/transaction, I can call a function that adds an orderer endpoint to the configuration. After performing that operation, I can compute a ConfigUpdate transaction that is ready for a signature workflow. An appropriate example should also be added to the example test that demonstrates this behavior."""
"FAB-17600","Story","fabric-common",1,"Implement helper function for retrieving policies for a specific org from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing policies for an organization without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving policies for a specific org (regardless of application/orderer/consortium org). The example test should also be updated to demonstrate usage of this helper."""
"FAB-17619","Story","fabric-common",2,"Wrap config transaction proto and move API to wrapped type","""Currently we pass a config object around to every update/API function, lets wrap the config proto so this:    becomes something like     """
"FAB-17639","Story","fabric-common",1,"Implement functions for adding and removing ACLs from an application group","""As a user of the Fabric channel configuration API, I would like to be able to update an application groups's ACLS by adding or removing ACLs.         *Acceptance*    I should be able to call this function to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     """
"FAB-17638","Story","fabric-common",1,"Implement helper function for retrieving application configuration from an existing config","""As a user of the Fabric channel configuration API, I would like to be able to retrieve existing application configuration without manually parsing the config transaction.         *Acceptance*    I should be able to call a function for retrieving application configuration that returns a config.Application."""
"FAB-17637","Story","fabric-common",1,"Implement functions for adding and removing capabilities from a config","""As a user of the Fabric channel configuration API, I would like to be able to add and remove application, orderer, and channel capabilities. Consider whether we should allow setting unsupported capabilities outside of the existing ones or if we should just have toggles (ie EnableV20ApplicationCapabilities() and Disable...)         *Acceptance*    I should be able to call these functions to modify a config transaction and then process further configuration updates on the modified config transaction. The examples test should be updated to demonstrate usage of this feature.     """
"FAB-17662","Story","fabric-common",1,"Remove Get Prefix on Accessors for ConfigTx functions","""[https://golang.org/doc/effective_go.html#Getters]         func (c *ConfigTx) GetAnchorPeers(...) -> func (c *ConfigTx) AnchorPeers(...)         [https://github.com/hyperledger/fabric/pull/880#discussion_r397418783]"""
"FAB-17733","Story","fabric-orderer",2,"Validate consenter certs when adding to application channel (and system channel)","""When adding a consenter node to the application channel, it is required that they have the relevant MSP that's contributing the node into the Orderer section... Otherwise any invokes on the channel fails since the channel is in a bad state... if they are going from one to two consenter, the channel is in a irrecoverable state.     We should check and see if the necessary certs are in MSP before allowing a consenter addition"""
"FAB-17965","Story","fabric-orderer",3,"Remove the system channel from a network with channels","""Allow a network running with a system channel to migrate and start operate with out it. The flow for doing so is:   * Enable the channel participation API on all OSNs (a staggered restart of all OSNs is required).   * Put the system channel into maintenance mode in order to prevent channel creation when it is removed, resulting in inconsistencies across orderers.   * Remove the system channel with the channel participation API.   * Prevent config transactions that change orderer channel membership on app channels, to avoid triggering a transition from Inactive <-> Raft    ** A simple option is to Halt all the channels, and   ** Halt the InactiveChainRegistry   * Removal should remove also all the channels the orderer is not a member of   * Restart every chain (or restart the server), in order to recreat the chains and convert every chain and its haltCalback pointers from Raft+Inactive to Raft+Follower   * Normal activity may resume"""
"FAB-18187","Story","fabric-build|fabric-release|fabric-sdk-go",3,"Back-porting Go Modules to 1.x","""Is there any chance that the migration to go modules could be back-ported for the latest 1.x release (1.4.8 at the time of this writing)?    I want to write a chain code with the latest 1.x version, but really dislike the legacy package management of go and the need to manage $GOPATH and other env vars (personal preference).    If I understand it correctly all it would take is a single commit that adds a go.mod file on the 1.x branch and then a release of a minor version that gets tagged so go can pick it up as a version. Also happy to send a PR with this if people support the idea. Please advise."""
